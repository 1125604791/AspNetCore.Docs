# Safety of isolated storage components with regard to untrusted data

__This document applies to the following frameworks:__

- .NET Framework (all versions)
- .NET Core 2.1+
- .NET 5.0+

The .NET Framework and .NET Core offer [isolated storage](https://docs.microsoft.com/en-us/dotnet/standard/io/isolated-storage) as a mechanism to persist data for a user, an application, or a component. This is a legacy component primarily designed for now-deprecated Code Access Security scenarios.

Various isolated storage APIs and tools can be used to read data across trust boundaries. For example, reading data from a machine-wide scope can aggregate data from other, possibly less-trusted user accounts on the machine. Applications which read from machine-wide isolated storage scopes should be aware of the consequences of reading this data.

## Security-sensitive APIs which can read from the machine-wide scope

If your component or application calls any of the below APIs, it reads from the machine-wide scope, and you should read further on safety concerns that may apply to your code base.

 * [`IsolatedStorageFile.GetEnumerator`](https://docs.microsoft.com/en-us/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getenumerator), passing a scope that that includes the `IsolatedStorageScope.Machine` flag
 * [`IsolatedStorageFile.GetMachineStoreForApplication`](https://docs.microsoft.com/en-us/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getmachinestoreforapplication)
 * [`IsolatedStorageFile.GetMachineStoreForAssembly`](https://docs.microsoft.com/en-us/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getmachinestoreforassembly)
 * [`IsolatedStorageFile.GetMachineStoreForDomain`](https://docs.microsoft.com/en-us/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getmachinestorefordomain)
 * [`IsolatedStorageFile.GetStore`](https://docs.microsoft.com/en-us/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.getstore), passing a scope that that includes the `IsolatedStorageScope.Machine` flag
 * [`IsolatedStorageFile.Remove`](https://docs.microsoft.com/en-us/dotnet/api/system.io.isolatedstorage.isolatedstoragefile.remove), passing a scope that that includes the `IsolatedStorageScope.Machine` flag

Additionally, the [isolated storage tool](https://docs.microsoft.com/en-us/dotnet/framework/tools/storeadm-exe-isolated-storage-tool) `storeadm.exe` (provided as part of Visual Studio and the .NET Framework SDK) is impacted if you call it with the `/machine` switch, as shown:

```txt
storeadm.exe /machine [any-other-switches]
```

If your application does not involve calls to the above APIs, or if your workflow does not involve calling `storeadm.exe` in this manner, then this document does not impact you.

## Impact in multi-user environments

As mentioned previously, the security impact from these APIs results from the fact that data written from within one trust environment is read from within a different trust environment. Isolated storage generally uses one of three locations to read+write data:

1. `%LOCALAPPDATA%\IsolatedStorage\` (e.g., `C:\Users\<username>\AppData\Local\IsolatedStorage\`), for the _User_ scope.
2. `%APPDATA%\IsolatedStorage\` (e.g., `C:\Users\<username>\AppData\Roaming\IsolatedStorage\`), for the _User|Roaming_ scope.
3. `%PROGRAMDATA%\IsolatedStorage\` (e.g., `C:\ProgramData\IsolatedStorage\`), for the _Machine_ scope.

The first two locations are isolated per-user. Windows ensures that different user accounts on the same machine cannot access each other's user profile folders. Two different user accounts who use the _User_ or _User|Roaming_ stores will not see each other's data and cannot interfere with each other's data.

The third location is shared across all user accounts on the machine. Different accounts can read from and write to this location, and they will be able to see each other's data.

(The above-listed paths may differ based on the version of Windows in use.)

Now consider a multi-user system with two registered users _Mallory_ and _Bob_. Mallory has the ability to access her user profile directory `C:\Users\Mallory\`, and she can access the shared machine-wide storage location `C:\ProgramData\IsolatedStorage\`. She cannot access Bob's user profile directory `C:\Users\Bob\`.

If Mallory wishes to attack Bob, she might write data to the machine-wide storage location, then attempt to influence Bob into reading from the machine-wide store. When Bob runs an application that reads from this store, that application will operate on the data Mallory placed there, but from within the context of Bob's user account. The remainder of this document contemplates various attack vectors and what steps applications can do to minimize their risk to these attacks.

__Note:__ In order for such an attack to take place, Mallory already requires a user account on the machine, the ability to place a file into a known location on the file system, and knowledge that Bob will at some point run an application which attempts to read this data. These are not threat vectors which would apply to standard single-user desktop environments like home PCs or single-employee enterprise workstations.

### Elevation of privilege

An __elevation of privelege__ attack occurs when Bob's application reads Mallory's file and automatically tries to take some action based on the contents of that payload. Consider an application that reads the contents of a startup script from the machine-wide store and passes those contents to `Process.Start`. If Mallory can place a malicious script inside the machine-wide store, then when Bob launches his application it will parse and launch this script _under the context of Bob's user profile_. Mallory has then gained access to Bob's account on the local machine.

### Denial of service

A __denial of service__ attack occurs when Bob's application reads Mallory's file and crashes or otherwise stops functioning correctly. Consider again the application mentioned previously, which attempts to parse a startup script from the machine-wide store. If Mallory can place a file with malformed contents inside the machine-wide store, she might cause Bob's application to throw an exception early in the startup path, preventing the application from launching successfully. She has then denied Bob the ability to launch the application under his own user account.

### Information disclosure

An __information disclosure__ attack occurs when Mallory can trick Bob into disclosing the contents of a file that Mallory does not normally have access to. Consider that Bob has a secret file `C:\Users\Bob\secret.txt` that Mallory wants to read. She knows the path to this file, but she cannot read it because Windows forbids her from gaining access to Bob's user profile directory.

Instead, Mallory places a hard link into the machine-wide store. This is a special kind of file that itself does not contain any contents; rather, it points to another file on disk. Attempting to read the hard link file will instead read the contents of the file targeted by the link. After creating the hard link, Mallory still cannot read the file contents because she does not have access to the target (`C:\Users\Bob\secret.txt`) of the link. However, Bob _does_ have access to this file.

When Bob's application reads from the machine-wide store, it now inadvertently reads the contents of his `secret.txt` file, just as if the file itself had been present in the machine-wide store. When Bob's application exits, if it attempts to re-save the file to the machine-wide store, it will end up placing an actual copy of the file in the `C:\ProgramData\IsolatedStorage\` directory. Since this directory is readable by any user on the machine, Mallory can then read the contents of the file at her leisure.

## Best practices to defend against these attacks

__Important:__ If your environment has multiple mutually untrusted users, __do not__ call the API `IsolatedStorageFile.GetEnumerator(IsolatedStorageScope.Machine)` or invoke the tool `storeadm.exe /machine /list`. Both of these assume that they're operating on trusted data. If an attacker can seed a malicious payload in the machine-wide store, that payload can lead to an elevation of privilege attack under the context of the user who runs these commands.

If operating in a multi-user environment, reconsider use of isolated storage features which target the _Machine_ scope. If an application must read data from a machine-wide location, prefer to read the data from a location that are writable only by admin accounts. The `%PROGRAMFILES%` directory and the `HKLM` registry hive are examples of locations which are admin-writable / world-readable. Data read from those locations is therefore considered trustworthy.

If your application must use the _Machine_ scope in a multi-user environment, validate the contents of any file that you read from the machine-wide store. If the application deserializing object graphs from these files, consider using safer serializers like `XmlSerializer` instead of dangerous serializers like `BinaryFormatter` or `NetDataContractSerializer`. Use caution with deeply-nested object graphs or object graphs which perform resource allocation based on the file contents.
